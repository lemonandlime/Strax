//  ViewController.swift//  Strax////  Created by Karl Söderberg on 2015-05-30.//  Copyright (c) 2015 lemonandlime. All rights reserved.//import Foundationimport MapKitimport UIKitimport RealmSwiftimport CoreLocationclass MapVC: UIViewController, MKMapViewDelegate {    @IBOutlet var mapView: MKMapView!    @IBOutlet var calculateTripButton: UIButton!    @IBOutlet var originButton: UIButton!    @IBOutlet var destinationButton: UIButton!    private var locationManager = CLLocationManager()    private var token: NotificationToken?    private var isSelectingSecondLocation = false    private var firstLocation: LocationAnnotation? {        didSet {            updateTripButton()        }    }    private var secondLocation: LocationAnnotation? {        didSet {            updateTripButton()        }    }    override func viewDidLoad() {        super.viewDidLoad()        setupMap()        setupRealmLocations()        refreshLocationButtons()    }    private func setupMap() {//                mapView.isScrollEnabled = false        //        mapView.isZoomEnabled = false        locationManager.requestWhenInUseAuthorization()        mapView.delegate = self        mapView.showsUserLocation = true    }    private func setupRealmLocations() {        token = Location.allLocations.observe { (change) in            switch change {            case .initial(let collection):                var annotations = [LocationAnnotation]()                collection.forEach {                    annotations.append(LocationAnnotation($0))                }                self.mapView.addAnnotations(annotations)                self.mapView.zoomToAnnotations()                break            case .update(let collection, deletions:let deletions, insertions:let insertions, modifications:_):                let currentAnnotations = self.mapView.annotations.flatMap({ return $0 as? LocationAnnotation })                let deletedIds: [String] = deletions.flatMap {                    return collection[$0].id                }                let annotationsToInsert: [LocationAnnotation] = insertions.flatMap {                    return LocationAnnotation(collection[$0])                }                let annotationsToDelete: [LocationAnnotation] = currentAnnotations.flatMap {                    if deletedIds.contains($0.id) {                        return $0                    }                    return nil                }                self.mapView.removeAnnotations(annotationsToDelete)                self.mapView.addAnnotations(annotationsToInsert)                self.mapView.zoomToAnnotations()                break            case .error(let error):                break            }        }    }    func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {        if annotation is MKClusterAnnotation {            let view = MKMarkerAnnotationView.init(annotation: annotation, reuseIdentifier: MKMapViewDefaultClusterAnnotationViewReuseIdentifier)            view.displayPriority = .defaultHigh            view.collisionMode = .rectangle            view.markerTintColor = UIColor(named: "dark-midnight-blue")            view.canShowCallout = true            view.glyphImage = #imageLiteral(resourceName:"bus-stop")            view.clusteringIdentifier = "STATION"            return view;        } else if annotation is LocationAnnotation {            let view = MKMarkerAnnotationView.init(annotation: annotation, reuseIdentifier: MKMapViewDefaultAnnotationViewReuseIdentifier)            view.displayPriority = .defaultHigh            view.markerTintColor = UIColor(named: "dark-midnight-blue")            view.glyphText = "T"            view.glyphTintColor = UIColor.white            view.collisionMode = .rectangle            view.canShowCallout = true            view.clusteringIdentifier = "STATION"            return view        } else if annotation is MKUserLocation {            let view = MKAnnotationView(annotation: annotation, reuseIdentifier: "UserLocation")            view.image = #imageLiteral(resourceName:"My Location Point")            return view;        }        return nil;    }    func mapView(_ mapView: MKMapView, clusterAnnotationForMemberAnnotations memberAnnotations: [MKAnnotation]) -> MKClusterAnnotation {        let cluster = MKClusterAnnotation(memberAnnotations: memberAnnotations)        cluster.title = "\(cluster.memberAnnotations.count) Stationer"        return cluster    }    func mapView(_ mapView: MKMapView, didSelect view: MKAnnotationView) {        if let cluster = view.annotation as? MKClusterAnnotation {            mapView.zoomToAnnotations(cluster.memberAnnotations, inset: UIEdgeInsets(top: 140, left: 100, bottom: 140, right: 100))        } else if let annotation = view.annotation as? LocationAnnotation {            if isSelectingSecondLocation {                secondLocation = annotation                if firstLocation == nil {                    isSelectingSecondLocation = false                }            } else {                firstLocation = annotation                isSelectingSecondLocation = true            }            refreshLocationButtons()        }    }    func updateTripButton() {        calculateTripButton.isHidden = firstLocation == nil || secondLocation == nil    }    @IBAction func didClickOriginButton() {        isSelectingSecondLocation = false        refreshLocationButtons()    }    @IBAction func didClickDestinationButton() {        isSelectingSecondLocation = true        refreshLocationButtons()    }    private func refreshLocationButtons() {        originButton.setTitle("från:" + (firstLocation?.title ?? "") , for: .normal)        destinationButton.setTitle("till:" + (secondLocation?.title ?? "") , for: .normal)        var activeButton = originButton!        var inactiveButton = destinationButton!        if isSelectingSecondLocation {            activeButton = destinationButton            inactiveButton = originButton        }        inactiveButton.transform = CGAffineTransform.identity        activeButton.transform = CGAffineTransform(scaleX: 1.2, y: 1.2)    }    @IBAction func onFindTravelButtonClicked() {        guard let from = firstLocation?.id, let to = secondLocation?.id else {            print("Dont have from and to locations")            return        }        findTravel(from: from, to: to)    }    private func findTravel(from: String, to: String) {        SLDataProvider.sharedInstance.getTrip(from, to: to) { result in            switch result {            case .success(let trips):                print(NSString(format: "Found and parsed %d trips", trips.count))                self.performSegue(withIdentifier: "Trip Details", sender: trips)            case .failure(let error):                print(error)            }        }    }    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {        if segue.identifier == "Trip Details",           let vc = segue.destination as? TripViewController,           let trips = sender as? [Trip] {            vc.trips = trips        }    }}